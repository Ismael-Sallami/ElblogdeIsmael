<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test de Prácticas de Sistemas Concurrentes y Distribuidos - Tema 2 - Exclusión Mutua</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            font-size: 18px;
        }
        h1 {
            text-align: center;
            color: #007bff;
            margin-bottom: 30px;
        }
        .question {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .question:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .question.correct {
            border-color: #28a745;
            background-color: #d4edda;
        }
        .question.incorrect {
            border-color: #dc3545;
            background-color: #f8d7da;
        }
        .explanation {
            background: #e7f3fe;
            border: 1px solid #b2d4fe;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }
        .author {
            margin-top: 20px;
            font-style: italic;
            text-align: center;
        }
        input[type="radio"] {
            margin-right: 10px;
            transform: scale(1.2);
        }
        input[type="button"] {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            transition: background-color 0.3s, transform 0.3s;
        }
        input[type="button"]:hover {
            background-color: #0056b3;
            transform: translateY(-3px);
        }
    </style>
</head>
<body>

    <h1>Test de Prácticas de Sistemas Concurrentes y Distribuidos - Tema 2 - Exclusión Mutua </h1>
    <!-- añadir preguntas -->
    <div class="question" id="q1">
        <p>¿Qué garantiza el algoritmo de Dijkstra para N procesos?</p>
        <ol type="a">
            <li><label><input type="radio" name="q1" value="0"> Acceso simultáneo a la sección crítica</label></li>
            <li><label><input type="radio" name="q1" value="0"> Eliminación de la necesidad de turnos</label></li>
            <li><label><input type="radio" name="q1" value="0"> Exclusión mutua con tiempo de espera limitado</label></li>
            <li><label><input type="radio" name="q1" value="0"> Uso de variables globales compartidas</label></li>
            <li><label><input type="radio" name="q1" value="1"> Exclusión mutua sin control de inanición</label></li>
        </ol>
    </div>
    
















    <!-- Añadir las preguntas adicionales de la misma manera -->

    <input type="button" value="¿Aprobarás?" onclick="checkAnswers()">
</form>

<div class="author">
    <p>Autor: Ismael Sallami Moreno</p>
</div>

<div id="results" style="margin-top: 20px;"></div>

<script>
    function checkAnswers() {
        let score = 0;
        const totalQuestions = 25;
        const resultsDiv = document.getElementById("results");
        resultsDiv.innerHTML = ""; // Limpiar resultados anteriores

        // Respuestas correctas
        const answers = {
            q1: { answer: "1", explanation: " Exclusión mutua sin control de inanición." },
            q2: { answer: "1", explanation: "El algoritmo de Dijkstra no garantiza la ausencia de inanición." },
            q3: { answer: "1", explanation: "El permiso para acceder a la sección crítica." },
            q4: { answer: "1", explanation: "El algoritmo de Peterson asegura que un proceso no avanza solo si no está más adelantado que los demás y es el último en asignar el turno." },
            q5: { answer: "1", explanation: "El uso de etapas en el algoritmo de Peterson asegura la exclusión mutua y equidad." },
            q6: { answer: "1", explanation: "Una de las condiciones de Dijkstra para la exclusión mutua es que un proceso fuera de la sección crítica no debe bloquear a otros procesos." },
            q7: { answer: "1", explanation: "El algoritmo de Dijkstra maneja las prioridades entre procesos implementando un contador global de turnos." },
            q8: { answer: "1", explanation: "El algoritmo de Peterson garantiza exclusión mutua y evita inanición." },
            q9: { answer: "1", explanation: "Progreso finito significa que los procesos tienen un tiempo finito para entrar a la sección crítica." },
            q10: { answer: "1", explanation: "El algoritmo de Peterson para N procesos garantiza exclusión mutua para cualquier cantidad de procesos." },
            q11: { answer: "1", explanation: "El algoritmo de Knuth soluciona la inanición garantizando que el tiempo de espera sea limitado para cada proceso y usando turnos circulares para la asignación de recursos." },
            q12: { answer: "1", explanation: "Después de usar la sección crítica, un proceso en el algoritmo de Peterson libera su bandera de 'solicitado'." },
            q13: { answer: "1", explanation: "Si dos procesos intentan acceder simultáneamente en el algoritmo de Peterson, se respetan las reglas de exclusión mutua." },
            q14: { answer: "1", explanation: "El algoritmo de Knuth introduce la técnica de retraso limitado en el acceso a la sección crítica." },
            q15: { answer: "1", explanation: "El método de refinamiento sucesivo resuelve el problema de exclusión mutua implementando bucles de espera activa para decidir el acceso." },
            q16: { answer: "1", explanation: "Una 'etapa' en el algoritmo de Peterson para N procesos es un nivel de prioridad fijo para los procesos y una fase de sincronización antes de la sección crítica." },
            q17: { answer: "1", explanation: "Para que un proceso entre a la sección crítica en el algoritmo de Peterson, su turno no debe coincidir o la clave del otro proceso debe ser falsa." },
            q18: { answer: "1", explanation: "No se realiza la salida de la espera activa de forma atómica." },
            q19: { answer: "1", explanation: "La exclusión mutua intenta evitar el acceso simultáneo de múltiples procesos a una sección crítica." },
            q20: { answer: "1", explanation: "Si todos los procesos solicitan acceso simultáneamente en el algoritmo de Dijkstra, uno de ellos accede según el turno asignado." },
            q21: { answer: "1", explanation: "El algoritmo de Knuth garantiza la exclusión mutua." },
            q22: { answer: "1", explanation: "El algoritmo de Dekker garantiza la exclusión mutua, pero puede causar inanición." },
            q23: { answer: "1", explanation: "La propiedad de equidad en exclusión mutua garantiza que los procesos acceden en orden sin preferencia indebida." },
            q24: { answer: "1", explanation: "La verificación de exclusión mutua en un algoritmo para N procesos garantiza que solo un proceso entre en la sección crítica a la vez." },
            q25: { answer: "1", explanation: "El principal problema de los bucles de espera activa es que pueden generar uso innecesario de recursos." }
        };

        for (let i = 1; i <= totalQuestions; i++) {
            const question = document.querySelectorAll(`input[name="q${i}"]:checked`);
            if (question.length > 0) {
            const selectedValues = Array.from(question).map(q => q.value);
            const correctAnswers = Array.isArray(answers[`q${i}`].answer) ? answers[`q${i}`].answer : [answers[`q${i}`].answer];
            const isCorrect = selectedValues.length === correctAnswers.length && selectedValues.every(val => correctAnswers.includes(val));
            
            if (isCorrect) {
                score++;
                document.getElementById(`q${i}`).classList.add('correct');
            } else {
                document.getElementById(`q${i}`).classList.add('incorrect');
                // Mostrar solo la justificación
                const explanation = answers[`q${i}`].explanation;
                const explanationDiv = document.createElement("div");
                explanationDiv.className = "explanation";
                explanationDiv.innerHTML = `<strong>Justificación:</strong> ${explanation}`;
                document.getElementById(`q${i}`).appendChild(explanationDiv);
            }
            }
        }

        // Cálculo de la nota sobre 10
        const grade = (score / totalQuestions) * 10;
        resultsDiv.innerHTML = `<h3>Tu puntuación es ${grade.toFixed(1)} sobre 10</h3>`;
        alert(`Tu puntuación es ${score} de ${totalQuestions}`);
    }
</script>

</body>
</html>
